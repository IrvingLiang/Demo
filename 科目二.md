# 科目二
参考链接：https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
#### 个人数据
```
自然人的enail地址，电话号码，生物特征，位置数据，ip地址，医疗信息，宗教信仰,社保号，婚姻状态，银行卡，口令，身份证，护照号
```
#### 个人敏感数据
```
https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
```
#### sql注入
    1.使用参数化查询：最有效的防护手段，对于sql语句中的表名、字段名、部分场景下的in条件不适用；（指直接把参数传进去？）
    2.对不可信数据进行白名单校验：适用于拼接sql语句中的表名、字段名
    3.对不可信数据进行转码：仅适用于SQL语句中由单引号或双引号限制的字段
#### xml
    1.xml实体解析导致的安全风险：XXE, 内部实体扩展
    2.针对XML数据应用的攻击：XPath，XXE, 内部实体扩展
    3.防止XML注入不包括使用XML Schema或 DTD校验
#### DOS攻击
    敏感异常
        1.Java.lang.OutOfMemoryError
        2.Java.lang.StackOverflowError
        3.javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）
        4.java.io.FileNotFoundException 泄露文件系统结构和文件名列举
        5、java.util.jar.JarException 泄露文件系统结构
        6、java.util.MissingResourceException                        资源列举
        7、java.security.acl.NotOwnerException                       所有人列举
        8、java.util.ConcurrentModificationException     可能提供线程不安全的代码信息
        9、java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举
#### 数据校验
    1、不可信数据进行校验时，禁止使用assert，
        因为：使用断言进行不可信数据校验存在以下问题：对不可信数据校验是系统实现逻辑的一部分，是必须要执行的；而断言是否生效依赖于运行时属性的状态， 存在被禁用的场景，导致不可信数据校验失效；
    2、"白名单"方式净化的方式包括删除，编码 ，替换
#### IO
    1、Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流 ：输入流，输出流，错误流
    2、规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码？
    3、规则6.3 防止让外部进程阻塞在输入输出流上？
    4、对于从流中读取一个字符或字节的方法，使用int类型的返回值
    5、FileChannel 是写操作 线程安全的
    6、FILE
        6.1、仅创建一个File类实例，Java是不会对文件进行读写的
        6.2、File实例可以判断是否目录或文件，因此文件与文件夹都可以处理
    7、字符和字节流
        7.1、Reader 是字符缓存流，可以支持按字符，数组，行来读取。
        7.2、InputSteam是字节缓存流，支持按字节读取文件和二进制数据
#### Java基础
    1、类加载顺序
        1.首先加载父类的静态字段或者静态语句块
        2.子类的静态字段或静态语句块
        3.父类普通变量以及语句块
        4.父类构造方法被加载
        5.子类变量或者语句块被加载
        6.子类构造方法被加载
    2、如何遍历删除数组元素避免ConcurrentModificationException
        1、使用removeIf方法或者Iterator提供的remove方法，用于删除当前元素
        2、使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnArrayList，ConcurrentHashMap或者CopyOnWriteArrayList。而不是ArrayList
        3、如果直接使用stream.list.foreach 或者 foreach 中删除元素则会引发ConcurrentModificationException，使用迭代器则不会，另外：
            foreach删除特例是ArrayList只有删除倒数第二个元素不会引发异常
            LinkedList的特例是只能删除倒数第二和第一个元素不引发异常
    3、switch
            switch不支持boolean，long，float
            defualt都是最后匹配的，如果被匹配到没有break，就会继续往下走。直到执行完或break；
    4、Java文件执行顺序选择
        加载，验证，初始化
    5、interface中变量的默认修饰符是public static final
    6、try catch
        1.不管有没有异常，即使try catch理由return语句，finally中的代码仍然会执行，但是return的返回值会实现保存下来，不管finally中的代码怎么样，返回值都不会改变，所以返回值是在finally执行前确定的
        2.finally中最好不要有return，都则程序会提前退出，返回值不是try catch中保存的值
        3.finally中指定代码发生异常时，直接忽略或仅记录日志，否则会导致finally代码块无法正常结束，进而导致try catch中的异常抛出，也会影响返回值
    7、Optional类
        禁止对Optional对象赋值/返回为null，或与null比较
        不应该返回Optional<'Integer>、Optional<'Long> 、 Optional<'Double> ，而应该使用OptionalInt 、 OptionalLong 、 OptionalDouble
    8、java使用DatagramPacket来打包数据，使用DatagramSocket来发送和接收数据
    9、Path中没有exists、isExists方法，Files中没有isExists方法
    10、fetchSize控制了JDBC每次读取数据的行数，越大性能越高，太大可能会内存溢出（OOM
#### NIO Selector
    1、一个Selector对应多个Channel，一个选择器最，可以同时被63个通道
    2、注册监听事件：Connect,Accept,Read,Write
    3、Java普通IO是面向流的，NIO是面向缓冲区的
    4、Selector等事件就绪后才会返回，避免IO阻塞，NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程
    5、Selector是Channel的复用器，不用Close
#### Buffer
    1、flip()方法将Buffer从写模式切换到读模式，将position值重置为0，limit的值设置为之前的position值2、BufferedReader是字符缓存流，能够更有效地读取字符、数组和行，提供按行读取的功能。
    3、BufferedInputStream是字节缓存流，能够按字节读取文件流，不仅能够读取文本文件，还能读取二进制数据，无按行读取的功能
    4、wrap()、slice()、duplicate()这些方法会创建一个新的buffer对象，但是修改这个新的buffer对象会导致原始的封装数据也被修改，反之亦然。
### 多线程
#### Synchronized
    1、使用Synchronized锁某个对象时，只有地址相同才会互斥
    ```
    public String a = “123”
        synchronized(a) {…}
        a对象引用的是常量池中的“123”的String的地址，如果在别的线程中也锁住了该地址，则会造成竞争
        public String a = new String(“123”)
        a对象引用的是新声明的字符串的地址，不会与其他线程造成竞争。
    ```
    2、synchronized修饰非静态方法时，锁住的是当前实例
    3、synchronized修饰静态方法时，锁住的是该类的Class对象
    4、synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。
    5、synchronized的代码块具有原子性
    6、在异常条件下，同步方法或者块同步中使用的对象内置锁会自动释放
