# 科目二
参考链接：https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
#### 个人数据
```
自然人的enail地址，电话号码，生物特征，位置数据，ip地址，医疗信息，宗教信仰,社保号，婚姻状态，银行卡，口令，身份证，护照号
```
#### 个人敏感数据
```
https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
```
#### sql注入
    1.使用参数化查询：最有效的防护手段，对于sql语句中的表名、字段名、部分场景下的in条件不适用；（指直接把参数传进去？）
    2.对不可信数据进行白名单校验：适用于拼接sql语句中的表名、字段名
    3.对不可信数据进行转码：仅适用于SQL语句中由单引号或双引号限制的字段
#### xml
    1.xml实体解析导致的安全风险：XXE, 内部实体扩展
    2.针对XML数据应用的攻击：XPath，XXE, 内部实体扩展
    3.防止XML注入不包括使用XML Schema或 DTD校验
#### DOS攻击
    敏感异常
        1.Java.lang.OutOfMemoryError
        2.Java.lang.StackOverflowError
        3.javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）
        4.java.io.FileNotFoundException 泄露文件系统结构和文件名列举
        5、java.util.jar.JarException 泄露文件系统结构
        6、java.util.MissingResourceException                        资源列举
        7、java.security.acl.NotOwnerException                       所有人列举
        8、java.util.ConcurrentModificationException     可能提供线程不安全的代码信息
        9、java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举
#### 数据校验
    1、不可信数据进行校验时，禁止使用assert，
        因为：使用断言进行不可信数据校验存在以下问题：对不可信数据校验是系统实现逻辑的一部分，是必须要执行的；而断言是否生效依赖于运行时属性的状态， 存在被禁用的场景，导致不可信数据校验失效；
    2、"白名单"方式净化的方式包括删除，编码 ，替换
#### IO
    1、Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流 ：输入流，输出流，错误流
    2、规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码？
    3、规则6.3 防止让外部进程阻塞在输入输出流上？
    4、对于从流中读取一个字符或字节的方法，使用int类型的返回值
    5、FileChannel 是写操作 线程安全的
    6、FILE
        6.1、仅创建一个File类实例，Java是不会对文件进行读写的
        6.2、File实例可以判断是否目录或文件，因此文件与文件夹都可以处理
    7、字符和字节流
        7.1、Reader 是字符缓存流，可以支持按字符，数组，行来读取。
        7.2、InputSteam是字节缓存流，支持按字节读取文件和二进制数据
#### Java基础
    1、类加载顺序
        1.首先加载父类的静态字段或者静态语句块
        2.子类的静态字段或静态语句块
        3.父类普通变量以及语句块
        4.父类构造方法被加载
        5.子类变量或者语句块被加载
        6.子类构造方法被加载
    2、如何遍历删除数组元素避免ConcurrentModificationException
        1、使用removeIf方法或者Iterator提供的remove方法，用于删除当前元素
        2、使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnArrayList，ConcurrentHashMap或者CopyOnWriteArrayList。而不是ArrayList
        3、如果直接使用stream.list.foreach 或者 foreach 中删除元素则会引发ConcurrentModificationException，使用迭代器则不会，另外：
            foreach删除特例是ArrayList只有删除倒数第二个元素不会引发异常
            LinkedList的特例是只能删除倒数第二和第一个元素不引发异常
    3、switch
            switch不支持boolean，long，float
            defualt都是最后匹配的，如果被匹配到没有break，就会继续往下走。直到执行完或break；
    4、Java文件执行顺序选择
        加载，验证，初始化
    5、interface中变量的默认修饰符是public static final
    6、try catch
        1.不管有没有异常，即使try catch理由return语句，finally中的代码仍然会执行，但是return的返回值会实现保存下来，不管finally中的代码怎么样，返回值都不会改变，所以返回值是在finally执行前确定的
        2.finally中最好不要有return，都则程序会提前退出，返回值不是try catch中保存的值
        3.finally中指定代码发生异常时，直接忽略或仅记录日志，否则会导致finally代码块无法正常结束，进而导致try catch中的异常抛出，也会影响返回值
    7、Optional类
        禁止对Optional对象赋值/返回为null，或与null比较
        不应该返回Optional<'Integer>、Optional<'Long> 、 Optional<'Double> ，而应该使用OptionalInt 、 OptionalLong 、 OptionalDouble
    8、java使用DatagramPacket来打包数据，使用DatagramSocket来发送和接收数据
    9、Path中没有exists、isExists方法，Files中没有isExists方法
    10、fetchSize控制了JDBC每次读取数据的行数，越大性能越高，太大可能会内存溢出（OOM
#### NIO Selector
    1、一个Selector对应多个Channel，一个选择器最，可以同时被63个通道
    2、注册监听事件：Connect,Accept,Read,Write
    3、Java普通IO是面向流的，NIO是面向缓冲区的
    4、Selector等事件就绪后才会返回，避免IO阻塞，NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程
    5、Selector是Channel的复用器，不用Close
#### Buffer
    1、flip()方法将Buffer从写模式切换到读模式，将position值重置为0，limit的值设置为之前的position值2、BufferedReader是字符缓存流，能够更有效地读取字符、数组和行，提供按行读取的功能。
    3、BufferedInputStream是字节缓存流，能够按字节读取文件流，不仅能够读取文本文件，还能读取二进制数据，无按行读取的功能
    4、wrap()、slice()、duplicate()这些方法会创建一个新的buffer对象，但是修改这个新的buffer对象会导致原始的封装数据也被修改，反之亦然。
### 多线程
#### Synchronized
    1、使用Synchronized锁某个对象时，只有地址相同才会互斥
    ```
    public String a = “123”
        synchronized(a) {…}
        a对象引用的是常量池中的“123”的String的地址，如果在别的线程中也锁住了该地址，则会造成竞争
        public String a = new String(“123”)
        a对象引用的是新声明的字符串的地址，不会与其他线程造成竞争。
    ```
    2、synchronized修饰非静态方法时，锁住的是当前实例
    3、synchronized修饰静态方法时，锁住的是该类的Class对象
    4、synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。
    5、synchronized的代码块具有原子性
    6、在异常条件下，同步方法或者块同步中使用的对象内置锁会自动释放
    
#### &#x20;violated

```java
1、volatile 无法实现原子性，只能实现可见性
2、使用volatile在效率上比较低
3、当且仅当满足一下条件才应该使用volatile变量：
	1、对变量的写入操作不依赖变量的当前值，或者你能保证只有单个线程更新变量的值
	2、该变量没有包含在其他变量的不变式中，防止影响其他变量
	3、防止代码重排
```

1.  sleep是Thread的方法，不会释放锁
2.  wait是object的方法会释放锁，通过notify或notifyAll唤醒，wait必须在synchronized中
3.  join的底层也是调用wait，所以会释放锁
4.  yield不会释放锁，而是会释放CPU给优先级更高的线程
5.  实现多线程

    1.  扩展Thread
    2.  实现Runnable接口
    3.  实现Callable接口

        与Runnable的区别：Callable的任务执行后返回值，call方法可以抛出异常，运行Callable任务可以拿到一个Future对象，表示异步计算的结果
6.  线程安全

    1.  Java多线程程序中，线程不允许抛出未捕获的Checked Exception

        ```sql
        1.默认异常处理即线程中run方法没有对抛出异常进行任何约束，只能由内部代码try catch处理，
        	设计理念：线程是独立执行的代码片段，线程的问题应该由线程自己来解决，而不要委托到外部
        2.未补捕获的异常：比如除以0这种异常，没有被捕获处理，则会一直往上抛，run方法抛出后不能在程序中对异常捕获，只能由jVM捕获，在调用线程的代码中，try catch可见是不会捕获到的
        ```


    2.  使用Thread.setUncaughtExceptionHandler方法自定义处理线程异常

        可以在线程定义时实现setUncaughtExceptionHandler方法，覆盖当前类的setUncaughtExceptionHandler来自定义线程异常处理类
7.  Semaphore

    1.  如下是信号量Semaphore的使用示例，==用于并发控制访问资源的线程数量，他通过协调各个线程，已保证合理的使用公共==资源
    2.  Semaphore的的内部实现与ReentrantLock类似，构造方法可以定义是否公平Semaphore(int n, boolean isFair)，代表是否按照顺序获取权限
    3.  信号量初始值比如为m，每signal一次，内部的数值就会减1，即数值为负数比如-n，代表有n个线程正在等待进入临界区，m个线程已在临界区（Acquire与ralease中间的代码）

        ```sql
        public static void main(String[] args) {
            //定义semaphore实例，设置许可数为3，即停车位为3个
            Semaphore semaphore = new Semaphore(3);
            //创建五个线程，即有5辆汽车准备进入停车场停车
            for (int i = 1; i <= 5; i++) {
                new Thread(() -> {
                    try {
                        System.out.println(Thread.currentThread().getName() + "尝试进入停车场...");
                        //尝试获取许可
                        semaphore.acquire();
                        //模拟停车
                        long time = (long) (Math.random() * 10 + 1);
                        System.out.println(Thread.currentThread().getName() + "进入了停车场，停车" + time +
                                           "秒...");
                        Thread.sleep(time);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        System.out.println(Thread.currentThread().getName() + "开始驶离停车场...");
                        //释放许可
                        semaphore.release();
                        System.out.println(Thread.currentThread().getName() + "离开了停车场！");
                    }
                }, i + "号汽车").start();    }
        }

        ```
8.  CountDownLatch

    可以设定多个线程相互等待达到指定位置（调用countDown后当前线程阻塞并进行数值-1，直到为0），当数值到达0时这些线程就会被唤醒继续运行后面的代码
9.  Java中断线程的3种方式

    1.  ==使用退出标志==，使线程正常退出：定义一个标志变量（如：volatile boolean），在线程中不断检测该变量，如果发现到达目标值，就让run方法结束
    2.  使用==stop方法==强行终止线程，

        1.  不推荐这个方法，他会立即停止run()方法中剩余的全部工作，包括catch与finaly语句中的代码，并抛出ThreadDeath异常，可能会导致一些清理性的工作得不到完成，
        2.  stop方法也会立即释放该线程所持有的锁，导致数据得不到同步，出现数据不一致的问题
        3.  Thread 类型提供了一系列的方法如 start()、stop()、resume()、suspend()、destory()等方法来管理线程。但是除了 start() 之外，其它几个方法都被声名为已过时(deprecated)。
    3.  ==使用interrupt()中断线程==（与方法1是类似的，只是Thread准备了这个标志位），代码中isInterrupted判断中断条件，中断后处理后退出run方法

        1.  Thread中定义了中断标志位，可使用public boolean Thread.isInterrupted()方法判断是否中断
        2.  使用public static boolean Thread.interrupted()方法判断是否中断，并清空当前的中断状态
10. 类加载器

    1.  加载器种类

        1.  根/引导类加载器（bootstrap class loader）：加载Java核心类库
        2.  扩展类加载器（extension class loader）：加载环境变量
        3.  系统类加载器：
    2.  加载机制

        1.  全盘负责：当一个类加载器负责加载某个class时，该class所依赖和引用其他class也将由该类加载器负责载入
        2.  当存在继承时，先加载父类和子类的静态代码块，再加载父类的代码块和构造方法，最后再加载子类的代码块和方法
11. GC

    1.  gc主要回收的是堆空间，栈上分配的临时变量调用完就会被释放
    2.  JDK1.7之前字符串在方法区，之后元空间代替永久代，并将字符串常量池移到了堆中
    3.  GC root对象包括：虚拟机栈（栈帧中的局部变量）引用，方法区静态属性应用的对象，方法区常量引用的对象，本地房发展栈中的对象
    4.  禁止主动GC（除非在密码，RMI等方面），尤其在周期性的逻辑中
    5.  IO操作，应在finally中关闭资源
    6.  将对象作为key存入map后，禁止对该对象的任意属性进行赋值操作，因为hashcode计算是根据对象的存储地址，对象的字段映射成一个数值，但是hashcode不会只会计算一次，后续不发生变化，如果下一个对象与该对象一样，如果前一个对象发生变化，==会导致两个对象的hashcode不一样？==
    7.  GC的性能指标-吞吐量= 运行用户代码时间/（运行用户代码时间+垃圾回收时间）
    8.  GC条件：主动gc，大对象直接创建在老年代会引发full gc，方法区内存不足，minior gc晋升老年代平均大小大于老年代内存，minior gc时to区可用内存小于对象大小，直接将该对象转存到老年代
    9.  jmap -histo命令查看JVM内存使用情况
    10. jstat：垃圾回收的信息
    11. jstack：查看Java进程的线程堆栈信息
12.
13. 1
14. 222


