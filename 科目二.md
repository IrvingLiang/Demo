# 科目二
参考链接：https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
#### 个人数据
```
自然人的enail地址，电话号码，生物特征，位置数据，ip地址，医疗信息，宗教信仰,社保号，婚姻状态，银行卡，口令，身份证，护照号
```
#### 个人敏感数据
```
https://blog.csdn.net/oocharlesxx_test/article/details/126098083#_178
```
#### sql注入
    1.使用参数化查询：最有效的防护手段，对于sql语句中的表名、字段名、部分场景下的in条件不适用；（指直接把参数传进去？）
    2.对不可信数据进行白名单校验：适用于拼接sql语句中的表名、字段名
    3.对不可信数据进行转码：仅适用于SQL语句中由单引号或双引号限制的字段
#### xml
    1.xml实体解析导致的安全风险：XXE, 内部实体扩展
    2.针对XML数据应用的攻击：XPath，XXE, 内部实体扩展
    3.防止XML注入不包括使用XML Schema或 DTD校验
#### DOS攻击
    敏感异常
        1.Java.lang.OutOfMemoryError
        2.Java.lang.StackOverflowError
        3.javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）
        4.java.io.FileNotFoundException 泄露文件系统结构和文件名列举
        5、java.util.jar.JarException 泄露文件系统结构
        6、java.util.MissingResourceException                        资源列举
        7、java.security.acl.NotOwnerException                       所有人列举
        8、java.util.ConcurrentModificationException     可能提供线程不安全的代码信息
        9、java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举
#### 数据校验
    1、不可信数据进行校验时，禁止使用assert，
        因为：使用断言进行不可信数据校验存在以下问题：对不可信数据校验是系统实现逻辑的一部分，是必须要执行的；而断言是否生效依赖于运行时属性的状态， 存在被禁用的场景，导致不可信数据校验失效；
    2、"白名单"方式净化的方式包括删除，编码 ，替换
#### IO
    1、Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流 ：输入流，输出流，错误流
    2、规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码？
    3、规则6.3 防止让外部进程阻塞在输入输出流上？
    4、对于从流中读取一个字符或字节的方法，使用int类型的返回值
    5、FileChannel 是写操作 线程安全的
    6、FILE
        6.1、仅创建一个File类实例，Java是不会对文件进行读写的
        6.2、File实例可以判断是否目录或文件，因此文件与文件夹都可以处理
    7、字符和字节流
        7.1、Reader 是字符缓存流，可以支持按字符，数组，行来读取。
        7.2、InputSteam是字节缓存流，支持按字节读取文件和二进制数据
#### Java基础
    1、类加载顺序
        1.首先加载父类的静态字段或者静态语句块
        2.子类的静态字段或静态语句块
        3.父类普通变量以及语句块
        4.父类构造方法被加载
        5.子类变量或者语句块被加载
        6.子类构造方法被加载
    2、如何遍历删除数组元素避免ConcurrentModificationException
        1、使用removeIf方法或者Iterator提供的remove方法，用于删除当前元素
        2、使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnArrayList，ConcurrentHashMap或者CopyOnWriteArrayList。而不是ArrayList
        3、如果直接使用stream.list.foreach 或者 foreach 中删除元素则会引发ConcurrentModificationException，使用迭代器则不会，另外：
            foreach删除特例是ArrayList只有删除倒数第二个元素不会引发异常
            LinkedList的特例是只能删除倒数第二和第一个元素不引发异常
    3、switch
            switch不支持boolean，long，float
            defualt都是最后匹配的，如果被匹配到没有break，就会继续往下走。直到执行完或break；
    4、Java文件执行顺序选择
        加载，验证，初始化
    5、interface中变量的默认修饰符是public static final
    6、try catch
        1.不管有没有异常，即使try catch理由return语句，finally中的代码仍然会执行，但是return的返回值会实现保存下来，不管finally中的代码怎么样，返回值都不会改变，所以返回值是在finally执行前确定的
        2.finally中最好不要有return，都则程序会提前退出，返回值不是try catch中保存的值
        3.finally中指定代码发生异常时，直接忽略或仅记录日志，否则会导致finally代码块无法正常结束，进而导致try catch中的异常抛出，也会影响返回值
    7、Optional类
        禁止对Optional对象赋值/返回为null，或与null比较
        不应该返回Optional<'Integer>、Optional<'Long> 、 Optional<'Double> ，而应该使用OptionalInt 、 OptionalLong 、 OptionalDouble
    8、java使用DatagramPacket来打包数据，使用DatagramSocket来发送和接收数据
    9、Path中没有exists、isExists方法，Files中没有isExists方法
    10、fetchSize控制了JDBC每次读取数据的行数，越大性能越高，太大可能会内存溢出（OOM
#### NIO Selector
    1、一个Selector对应多个Channel，一个选择器最，可以同时被63个通道
    2、注册监听事件：Connect,Accept,Read,Write
    3、Java普通IO是面向流的，NIO是面向缓冲区的
    4、Selector等事件就绪后才会返回，避免IO阻塞，NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程
    5、Selector是Channel的复用器，不用Close
#### Buffer
    1、flip()方法将Buffer从写模式切换到读模式，将position值重置为0，limit的值设置为之前的position值2、BufferedReader是字符缓存流，能够更有效地读取字符、数组和行，提供按行读取的功能。
    3、BufferedInputStream是字节缓存流，能够按字节读取文件流，不仅能够读取文本文件，还能读取二进制数据，无按行读取的功能
    4、wrap()、slice()、duplicate()这些方法会创建一个新的buffer对象，但是修改这个新的buffer对象会导致原始的封装数据也被修改，反之亦然。
### 多线程
#### Synchronized
    1、使用Synchronized锁某个对象时，只有地址相同才会互斥
    ```
    public String a = “123”
        synchronized(a) {…}
        a对象引用的是常量池中的“123”的String的地址，如果在别的线程中也锁住了该地址，则会造成竞争
        public String a = new String(“123”)
        a对象引用的是新声明的字符串的地址，不会与其他线程造成竞争。
    ```
    2、synchronized修饰非静态方法时，锁住的是当前实例
    3、synchronized修饰静态方法时，锁住的是该类的Class对象
    4、synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。
    5、synchronized的代码块具有原子性
    6、在异常条件下，同步方法或者块同步中使用的对象内置锁会自动释放

#### &#x20;violated

```java
1、volatile 无法实现原子性，只能实现可见性
2、使用volatile在效率上比较低
3、当且仅当满足一下条件才应该使用volatile变量：
	1、对变量的写入操作不依赖变量的当前值，或者你能保证只有单个线程更新变量的值
	2、该变量没有包含在其他变量的不变式中，防止影响其他变量
	3、防止代码重排
```

1.  sleep是Thread的方法，不会释放锁
2.  wait是object的方法会释放锁，通过notify或notifyAll唤醒，wait必须在synchronized中
3.  join的底层也是调用wait，所以会释放锁
4.  yield不会释放锁，而是会释放CPU给优先级更高的线程
5.  实现多线程

    1.  扩展Thread
    2.  实现Runnable接口
    3.  实现Callable接口

        与Runnable的区别：Callable的任务执行后返回值，call方法可以抛出异常，运行Callable任务可以拿到一个Future对象，表示异步计算的结果
6.  线程安全

    1.  Java多线程程序中，线程不允许抛出未捕获的Checked Exception

        ```sql
        1.默认异常处理即线程中run方法没有对抛出异常进行任何约束，只能由内部代码try catch处理，
        	设计理念：线程是独立执行的代码片段，线程的问题应该由线程自己来解决，而不要委托到外部
        2.未补捕获的异常：比如除以0这种异常，没有被捕获处理，则会一直往上抛，run方法抛出后不能在程序中对异常捕获，只能由jVM捕获，在调用线程的代码中，try catch可见是不会捕获到的
        ```


    2.  使用Thread.setUncaughtExceptionHandler方法自定义处理线程异常

        可以在线程定义时实现setUncaughtExceptionHandler方法，覆盖当前类的setUncaughtExceptionHandler来自定义线程异常处理类
7.  Semaphore

    1.  如下是信号量Semaphore的使用示例，==用于并发控制访问资源的线程数量，他通过协调各个线程，已保证合理的使用公共==资源
    2.  Semaphore的的内部实现与ReentrantLock类似，构造方法可以定义是否公平Semaphore(int n, boolean isFair)，代表是否按照顺序获取权限
    3.  信号量初始值比如为m，每signal一次，内部的数值就会减1，即数值为负数比如-n，代表有n个线程正在等待进入临界区，m个线程已在临界区（Acquire与ralease中间的代码）

        ```sql
        public static void main(String[] args) {
            //定义semaphore实例，设置许可数为3，即停车位为3个
            Semaphore semaphore = new Semaphore(3);
            //创建五个线程，即有5辆汽车准备进入停车场停车
            for (int i = 1; i <= 5; i++) {
                new Thread(() -> {
                    try {
                        System.out.println(Thread.currentThread().getName() + "尝试进入停车场...");
                        //尝试获取许可
                        semaphore.acquire();
                        //模拟停车
                        long time = (long) (Math.random() * 10 + 1);
                        System.out.println(Thread.currentThread().getName() + "进入了停车场，停车" + time +
                                           "秒...");
                        Thread.sleep(time);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        System.out.println(Thread.currentThread().getName() + "开始驶离停车场...");
                        //释放许可
                        semaphore.release();
                        System.out.println(Thread.currentThread().getName() + "离开了停车场！");
                    }
                }, i + "号汽车").start();    }
        }

        ```
8.  CountDownLatch

    可以设定多个线程相互等待达到指定位置（调用countDown后当前线程阻塞并进行数值-1，直到为0），当数值到达0时这些线程就会被唤醒继续运行后面的代码
9.  Java中断线程的3种方式

    1.  ==使用退出标志==，使线程正常退出：定义一个标志变量（如：volatile boolean），在线程中不断检测该变量，如果发现到达目标值，就让run方法结束
    2.  使用==stop方法==强行终止线程，

        1.  不推荐这个方法，他会立即停止run()方法中剩余的全部工作，包括catch与finaly语句中的代码，并抛出ThreadDeath异常，可能会导致一些清理性的工作得不到完成，
        2.  stop方法也会立即释放该线程所持有的锁，导致数据得不到同步，出现数据不一致的问题
        3.  Thread 类型提供了一系列的方法如 start()、stop()、resume()、suspend()、destory()等方法来管理线程。但是除了 start() 之外，其它几个方法都被声名为已过时(deprecated)。
    3.  ==使用interrupt()中断线程==（与方法1是类似的，只是Thread准备了这个标志位），代码中isInterrupted判断中断条件，中断后处理后退出run方法

        1.  Thread中定义了中断标志位，可使用public boolean Thread.isInterrupted()方法判断是否中断
        2.  使用public static boolean Thread.interrupted()方法判断是否中断，并清空当前的中断状态
10. 类加载器

    1.  加载器种类

        1.  根/引导类加载器（bootstrap class loader）：加载Java核心类库
        2.  扩展类加载器（extension class loader）：加载环境变量
        3.  系统类加载器：
    2.  加载机制

        1.  全盘负责：当一个类加载器负责加载某个class时，该class所依赖和引用其他class也将由该类加载器负责载入
        2.  当存在继承时，先加载父类和子类的静态代码块，再加载父类的代码块和构造方法，最后再加载子类的代码块和方法
11. GC

    1.  gc主要回收的是堆空间，栈上分配的临时变量调用完就会被释放
    2.  JDK1.7之前字符串在方法区，之后元空间代替永久代，并将字符串常量池移到了堆中
    3.  GC root对象包括：虚拟机栈（栈帧中的局部变量）引用，方法区静态属性应用的对象，方法区常量引用的对象，本地房发展栈中的对象
    4.  禁止主动GC（除非在密码，RMI等方面），尤其在周期性的逻辑中
    5.  IO操作，应在finally中关闭资源
    6.  将对象作为key存入map后，禁止对该对象的任意属性进行赋值操作，因为hashcode计算是根据对象的存储地址，对象的字段映射成一个数值，但是hashcode不会只会计算一次，后续不发生变化，如果下一个对象与该对象一样，如果前一个对象发生变化，==会导致两个对象的hashcode不一样？==
    7.  GC的性能指标-吞吐量= 运行用户代码时间/（运行用户代码时间+垃圾回收时间）
    8.  GC条件：主动gc，大对象直接创建在老年代会引发full gc，方法区内存不足，minior gc晋升老年代平均大小大于老年代内存，minior gc时to区可用内存小于对象大小，直接将该对象转存到老年代
    9.  jmap -histo命令查看JVM内存使用情况
    10. jstat：垃圾回收的信息
    11. jstack：查看Java进程的线程堆栈信息
12. 数据类型
  1. Integer在-128到127之间存在缓存，可以使用==比较
  2. byte的范围在-128到127中、
  3. switch不支持的类型包括boolean long
  4. map属于中间结果？
  5. long会根据虚拟机的位数变化长度，int永远是32位
  6. double+int会被转换为double，及转换成精度更高的
  7. int+String会被转换为string
  8. 基本数据类型转换精度从低到高（char，byte，short）-> int -> long -> float -> double
13. 反射
  1. class类
      1. getField、getFileds：返回返回对象的域的对象或或数组，可以用于返回类或接口指定名称的成员
      2. getDeclaredField，getDeclaredFileld：返回指定名称的声明的字段
      3. getMethod方法则根据方法名称和相关参数，来定位需要查找的method对象并返回
      4. getDeclaredMethods方法的区别在于，返回一个method对象数组
14. 集合（Collection）
  1. TreeMap可以有null的key，不能有null的value
  2. hashMap可有null的key和value，不保证顺序
  3. LinkedHashMap会将最后一次访问的放在最后一位
  4. set不允许重复元素，无序
  5. 线程安全
    1. 线程安全的集合：Vector,HashTable,StringBuffer,ConcurrentHashMap,stack
    2. 非线程安全的集合：ArrayList，LinkedList,HashMap,HashSet,TreeMap,TreeSet,StrignBuilder,LinkedHashSet,LinkedHashMap
    3. 长度：ArrayList(默认10)，Vector（默认10），StringBuilder（默认16），StringBuffer（默认16），HashSet（默认16）
15. 栈帧
  1. 存储方法的局部变量，操作数堆栈，动态链接，方法返回地址
  2. 大小在程序编译是确定
  3. 堆外内存
     1. -Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小
     2. -Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn
     3. -Xss设置每个线程可使用的内存大小
     4. XX:DirectMemorySize用来设置堆外内存
16. jvm
  1. jmap: 分析堆内存，分析内存逃逸，生成dump文件， 打印对象的个数与大小
  2. jstack：分析死锁，线程快照等，查看线程运行状态
  3. jstat: 查看gc垃圾话回收，类加载
  4. jinfo：查看系统参数
17. 异常
  1. 运行时异常：一般可由虚拟机接管，**要么线程终止，要么主程序终止**
    如：**RuntimeException，ArrayStoreException，ClassCastException，IllegalArgumentException，IndexOutOfBoundsException，NoSuchElementException，NullPointerException**
18. 泛型
  1. T与？的区别
    1. List<T>：**这个T是一个形参**，可以理解为一个占位符，被使用时会被替换为具体的类型
    2. List<?>：**?而是一个实参**，是Java定义的一种特殊的类型，比Object更特殊，比如：List<?>是List<String>的父类，，但List<Object>不是List<String>的父类
    3. <? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类，**适合读** ,<? super T> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object，**适合写**
    **注意这个上界是指里面的参数的上下界，如果指定了上界，那么他不可以add任何元素除了null，因为不清楚他是哪个子类，且只能发现向上转型。因此不知道改传入什么，如果制定了下界，那可以加入一个T的子类**
19. Clone
  需要实现Clonable接口，clonable接口中的clone方法默认是浅拷贝（引用传递）：会创建新的拷贝对象，但是对象中的变量指向相同的地址
  clone方法本身是浅拷贝，如果要实现深拷贝可以使用序列化跟反序列化实现
20. 排版
    1. 每行代码最多120行
    2. 每个文件最多2万行
    3. 避免方法过长，不超过50行
    4. 嵌套不超过4层，入参不超过5个
    5. 一个源文件按顺序包含版权，package，import，顶层类，且用空行分割
    6. import包应该按照安卓，华为公司，其他商业组织，其他开元第三方，net/org开源组织、最后java的分类顺序出现，并用一个空行分组
21. Stream
    1. 无存储，为函数编程而生，惰性执行（任何中间操作不会立即执行），一次消费（stream只能消费一次，一旦遍历过就会失效，想再次遍历就会重新生成）
    2. 中间操作（filter，map,flaotMap,distinct,sorted,limit,skip）
    3. 中断操作：foreach，toArray，reduce，collect，min/max/count,AllMatch/anyMatch/noneMatch,findFirst/findAny
22. ORM框架
    1. $在预编译阶段会替换变量，会存在SQL注入问题.#{}传入的参数，ORM会默认将其当做字符串处理
    2. ORM依赖于JDBC和DataSource
    3. ORM有多种实现，主流的Mybatis与Hibernate
    4. ORM即**对象关系转换**，即数据库的单条数据与Java对应之间的映射
23. 序列化
    1. 实现Serializable接口的可序列化类建议不使用默认的serialVersionUID
    2. Xstream 比XMLDecoder更安全，
    3. 禁止序列化非静态的内部类
       **java编译器编译某些构造方法时，他会创建合成结构，与合成结构相关的代码在源代码中是不存在的，最重要的是java编译器可能会创建不同的结构，这意味着，.class文件在不同的实现中也会有所不同，因此如果将内部类序列化，然后用不同的JRE对其反序列化，可能导致兼容性问题**
    4. 子类实现了Serializable接口，父类没有实现，要想架构父类独对象也序列化，需要父类也实现Serializable接口
    5. 序列化对象中的HashMap，HashSet或hashTable不能包含对象自身的应用
    6. 建议除非必须使用的第三方接口必须实现Serializable接口，否则请选用其他方式代替
      **序列化的主要场景是在进程之外保存对象，并在需要的时候重新获取对象，它会增大安全风险，容易透露对象的物理实现，使一个类对最初的内部表示产生依赖，且实现序列化很有挑战，因此非不得已，不使用Serializable接口实现序列化**
    7. 注意:Serializable接口其实是一个空实现，更像是一个标记，标记这个类可以被序列化，指定的SerializableVersionUid有向前后的兼容问题（使用系统给的序列化，如果后面成员发生了增删），并且序列化后的文件会保存他们的类信息，如果反序列化时两个类的成员或名字不一样则会导致失败，而Json则不关注类信息，单纯的处理数据，两个对象内部一致，类名不一样序列化后的数据是完全一样的
    8. 字段不被序列化的方式
      1. transient 属性修饰的变量不会被序列化
      2. 将不需要被序列化的字段抽取出来放到父类中，子类实现 Serializable 接口，父类不实现，根据父类序列化规则，父类的字段数据将不被序列化
      3. .通过 ObjectStreamField 数组来声明类需要序列化的对象
      ```
      private static final ObjectStreamField[] serialPersistentFields = {
            new ObjectStreamField("name", String.class),
            new ObjectStreamField("age", Integer.class)
    };
      ```
24. 继承,重载，覆盖
    1. 子类继承父类，只能覆盖同名的方法，不会覆盖同名的变量
    2. 子类必须调用父类的构造方法，否则编译失败
    3. 重载：是指一个类定义多个同名的方法，他们的参数列表是不一样的（个数，类型，顺序）
      1. 子类不能重载父类的private方法
      2. 重载具有相同名字和不同的**签名**
    4. 覆盖
      1. 子类覆盖父类方法条件：必须方法的函数名，参数，返回值和所抛出的异常都不相同（非private的）
      2. 子类不能父类的私有private方法，因为子类不能继承父类的私有方法，所以子类不是覆盖而是定义了一个新的方法
      3. 子类不能覆盖父类的static方法，但是可以重写并屏蔽父类的静态方法
      4. 子类不能覆盖父类的final方法
    5. 隐藏
      1. 子类会隐藏与父类相同名称的成员变量，内部类
    6. 遮蔽（变量与变量）：
        指一个声明在其作用域内的部分地方因为同名的声明而无法直接访问的情况。譬如方法的参数以及局部变量的声明会遮蔽住同名的类成员变量
    7. 遮掩（变量与类型）
        遮掩指当一个简单名可以被同时解释为变量名、类型名或包名时，因为变量名优先于类型名，类型名优先于包名，所以导致一些名称无法直接访问的情况。譬如我们同时有叫做 org 的变量和叫做 org 的包，那么你使用 org 时它会被优先解释为变量，这个时候我们需要以 import 来避免这种情况
25. 黑盒测试
    1. 划分等价类的六大原则
      1. 在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类
      2. 在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类
      3. 在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类. 布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。
      4. 在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。
      5. 在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。
      6. 在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类
26. 组合测试-因子组合
    1. AC （All Combinations）所有组合 ：组合个数=所有因子的取值个数乘积
    2. EC（ Each Choice ）出现一次就行：组合个数=最多取值的因子的取值个数
    3. BC（Basic Choice）以一个为基础 每次改变一个：组合个数=所有因子的取值-因子个数+1
    4. N-wise：每N个测试因子的取值组合至少覆盖一次
    5. EC 是最少的的数据组合覆盖测试方式。
27. Linux chmod权限
    ```
    Linux的权限码：如777 分别代表拥有者权限，群组权限，其他权限。每个7即111代表可读可写可执行，0则是无任何权限，4则是100，这个指只有读的权限
    特别的：用3个位代表读写执行，转换为8进制就是0-7的数字，三个八进制数字则代表三种权限
    ```
28. 正则
  1. \d，\w和\s，w 是 word 的简写，表示匹配一个常用字符，包括字母、数字、下划线。**s 是 space 的简写**，表示匹配一个空格.
  2. 将字母换成大写，就表示相反的意思。用 \d 你可以匹配一个数字，\D 则表示匹配一个非数字.
  3. . 符号匹配任意字符一次
  4. * 符号匹配字符任意次
  5. + 符号匹配字符至少1次
  6. ？符号匹配字符1或0次
  7. [] 取反的方式是：[^]，比如不能是 [123] 的表示方法为 [^123] 或者 [^1-3]
  8. ^在[]外表示开头,$表示结尾
