日常一看
	

Wifi密码：dt76kmyn
redis缓存淘汰机制
	定时删除：设置过期时间
	惰性删除：用的时候发现过期就删除
	定期删除：随机收取后删除
	内存淘汰机制：
                noeviction:不删除策略，达到最大内存限制的时候，如果需要更多内存，直接返回错误信息
    		allkeys-lru:所有的key通用，优先删除最近最少使用的key
    		volatile-lru：只限制设置了expire即过期时间的部分，优先删除最近最少使用的key
    		allkeys-radom：所有的key通用，随机删除一部分key
    		volatile-random：只限于设置了过期时间的部分，随机删除一部分key
    		volatile-ttl：只限于设置expire的部分，优先删除剩余时间（time to live,TTL）短的key
   		 对于没有设置过期的时间的key，当使用时只对有过期时间的处理，没有设置过期时间的不处理
    

mat 执行sql


Java锁升级
	偏向性锁
	自旋锁（轻量级）
	重量级锁
	
	
1.3 死锁的条件与规避
条件(4)
* 资源互斥（不能一个线程同时持有）
* 资源不可抢夺
* 占用并等待资源
* 循环等待资源：线程等待别的线程持有的资源，而这些线程又反过来等待第一个线程持有的资源
规避(5)
* 粗锁法：使用粗粒度的锁代替多个锁而消除占用并等待（这样只需要申请少量的锁），缺点是显著降低了并发性并可能导致资源浪费
* 锁排序法：相关线程使用全局统一的顺序申请锁，消除了循环等待条件
* 使用reetrantLock.tryLock申请锁，可以设定一个超时时间，如果在时间内没有申请到，则使当前线程暂停，直到整个锁申请成功，线程暂停时将释放所有已经占用的锁，这样就消除了占用并等待条件
* 开放调用：一个方法在调用外部方法的时候不持有任何锁，这避免了占用并等待条件
* 使用锁的替代品：如相关的关键字
规避死锁的终极方法就是不使用锁，比如：无状态对象，线程特有对象，volatile关键字，不仅能避免锁的开销，还能直接避免死锁
死锁的恢复
1. 如果死锁是内部锁或者显示锁的并锁的申请是Lock.lock()调用实现的，那么只能重启Java虚拟机
2. 如果代码中使用的是显示锁且锁的申请是通过Lock.lockInterruptibly()调用实现的那么理论上是可恢复的，其实死锁的恢复可操作性性拧不强，恢复的尝试是徒劳的（故障线程无法响应中断）且有害的（可能导致其他线程活性故障）
基本思想：定义一个工作者线程专门用来检测死锁并进行恢复，如检测到死锁，则随机选取一个死锁线程并给其发送中断。该中断使得一个任意的死锁线程被Java虚拟机唤醒，从而抛出一个InterruptedException异常，并根据异常将已经持有的资源释放掉，破坏了占用并等待条件，接着工作者继续检测继续发送中断直到系统中不再存在死锁

锁死：信号丢失导致线程的唤醒条件永远无法满足，或嵌套监视器锁死（嵌套锁进入第一层才能申请下一个锁，另一个线程进入第一个锁才能修改那个线程的保护条件）

活锁：线程一直处于运行状态，即比较谦让，加不上就放开已获得的资源重试，最终导致一直无法运行结束

线程饥饿：线程一直无法获取所需的资源而导致任务一直无法进展，比如非公平锁会导致一些优先级低的线程一直无法获得资源

常见线程池
	cachedThreadPool：周期性执行任务。核心线程为0，非核心线程为无限大，适用于执行周期性的任务,使用SynchronousQueue
	secudleThreadPool：
	singleThreadPool：只有一条线程来执行任务，适用于有顺序的任务的应用场景 ，使用LinkedBlockingQueue
	FixedThreadPool：定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程，使用LinkedBlockingQueue
线程池大小的参考值设置
	如果是CPU密集性任务，可以尽量压榨cpu，参考值可以设置为cpu个数+1
	如果是IO密集任务，由于io操作一般都是阻塞的，那么就可以把参考值设置为cpu个数的2倍
任务队列的实现
	ArrayBlockingQueue：基于数组的先进先出，必须指定大小，适合并发量高的
	LinkedBlockingQueue：基于链表的先进先出，如果没有指定大小，默认是Integer.MAX_VALUE，适合并发量低的
	synchronousQueue：这个队列要求只有创建一个任务才会移除一个任务，反之也一样，放在线程池中就是，不保存提交的任务，而是将直接新建一个线程去执行

拦截器与过滤器
	拦截器：继承HandlerInterceptor接口，实现prehandle，postHandle，afterCompletion方法
			主要应用：判断用户是否登录
			基于Springmvc及Java反射机制,在spring容器内，因此在请求的方法前中后都可以起作用
	过滤器：继承Filter，实现init，dofilter，destory方法，
			主要应用：安全登录（过滤非法请求），自动登录（如果cookie中有相关信息，让其登录），黑名用户拒接登录，敏感词过滤
			基于函数回调，依赖于servlet,
spring bean的生命周期：                                     惊群 cap 漏桶  mvcc  回滚机制
		1、实例化bean（执行构造方法）
		2、属性赋值：
					a、ioc进行属性注入，
					b、如果bean关联了ApplicationAware，BeanNameAware，BeanFactoryAwaer或调用执行相应的								setApplcation，setBeanName,setBeanFactory方法
		3、初始化: 如果实现了BeanPostProcessor,就会调用postProcessBeforeInitialize(初始化前)—>afterPropertiesSet（属性注入后）—>init初始化方法—>postProcessAfterInitialize（初始化后）方法—>bean准备就绪
		4、销毁：如果实现了disposableBean则会调用destory方法调用finalize（不适于多次调用）
GCRoot
	虚拟栈的栈帧中存储的对象
	本地方法引用的对象
	方法区中静态常量和常量引用的对象
Tip ： 常量引用的对象：一种特殊的变量，他的值被设定之后，在程序运行过程中不允许被改变，Java中用final修饰，命名一般使用大写字符，c中用const引用
mysql like 优化：

抽象类：   抽象类中的方法可以是抽象（不用实现）的也可以是非抽象的（实现了），抽象类可以被继承
             导出类向上转型为抽象类的对象，那么该对象就获得了导出类实现了的方法，
	    一个有抽象方法的类必须是抽象类，否则编译器会报错，
	    Instrument ins=new Wind();
	      ins.play();//Instrument是抽象类，其引用可以用继承并实现了该接口的Wind向上转型得到，这时调用play方法，是已经实现了得Wind方法
	抽象类中的方法可以声明为final的防止被子类篡改
接口：      1.接口中的方法默认是public，abstract的，可以显示加入public，abstract也可以不写，
            2.接口中的域（成员变量）默认是static和final的
	    3.接口中的tostring方法不必写出，因为toString是根类Object的一部分
	      接口也可以用类似上面抽象类的方法进行向上转型实现接口与实现分离

注意：
	接口和抽象类中都可以有静态对象，并且可以直接调用
	


协程：运行在线程之上，他的切换是在用户态进行的，避免了大量的上下文切换导致的用户态与内核态之间切换的代价，
	  协程使用时应避免使用阻塞的io以防止导致线程的暂停导致的切换，即对系统io进行封装改用异步调用的方式，最好是寄希望于变成语言原生的支持，非阻塞io即NIO
分段锁

CAS(a,1,2);

if(a==1){
  a=2;
}

Executors.newFi

秒杀系统设计：
体验
数量

抽奖系统设计：
奖品抽奖算法：提前生成，；
稀疏数据；
奖品抽完了：抽奖系统



数据库优化
用两个栈实现一个队列
注册中心和nginx的区别

线程池

常见四个线程池

mysql数据库主从复制

主从数据库的三个数据一致性解决方案：半复制，中间件，cache组件

线程交替打印

数据库隔离级别：读未提交，读已提交-，可重复读-，串行
NIO
Jdk8的垃圾回收

内存屏障
	可见性
		加载屏障
		存储屏障
	有序性
		获取屏障
		释放屏障
	

reetrantLock也是一个可重入锁，他可以指定公平与非公平

Redis 删除策略
Autowired注解的类是怎么加载的
redolog undolog
explain
jmap jstack


● 代码审查（代码扫码、依赖分析、生成分析报告）
● pod监控（部署状态、可用节点数、pod的cpu、内存、网络）
● 服务内部监控（接口请求频次、未被拦截到的异常、JVM、HTTP、GRPC、POOL …）
● 数据库监控（Redis使用情况、TiDB使用情况、慢SQL、事务）

Java类的执行顺序
1. 父类的静态变量和静态块赋值（按照声明顺序）
2. 自身的静态变量和静态块赋值（按照声明顺序）
3. main方法
4. 父类的成员变量和块赋值（按照声明顺序）
5. 父类构造器赋值
6. 自身成员变量和块赋值（按照声明顺序）
7. 自身构造器赋值
8. 静态方法，实例方法只有在调用的时候才会去执行
Spring bean的创建过程
1. 利用该类的构造方法来实例化得到一个对象（但是如何一个类中有多个构造方法，Spring则会进行选择，这个叫做推断构造方法）
2. 得到一个对象后，Spring会判断该对象中是否存在被@Autowired注解了的属性，把这些属性找出来并由Spring进行赋值（这个就是依赖注入过程）
3. 依赖注入后，Spring会判断该对象是否实现了BeanNameAware接口、 BeanClassLoaderAware接口、BeanFactoryAware接口，如果实现了，就表示当前对象必须实现该接口中所定义的setBeanName()、setBeanClassLoader()、setBeanFactory()方法，那Spring就会调用这些方法并传入相应的参数（Aware回调）
4. Aware回调后，Spring会判断该对象中是否存在某个方法@PostConstruct注解了，如果存在，Spring会调用当前对象的此方法（初始化前）
5. 紧接着，Spring会判断该对象是否实现了InitializingBean接口，如果实现了，就表示当前对象必须实现该接口中的afterPropertiesSet()方法，那Spring就会调用当前对象中的afterPropertiesSet()方法（初始化）

6. 最后，Spring会判断当前对象需不需要进行AOP，如果不需要那么Bean就创建完了，如果需要进行AOP，则会进行动态代理并生成一个代理对象做为Bean（初始化后）



Java相关问题
面试回答模板：
1.关于面试官：有的属于和蔼型有的属于高冷型，可随机应变，把握主旨将自己的项目和经历讲清楚，可以问问他们是做什么的以便把握方向，符合的项目或经验可以重点突出，你觉得很不错的项目也可以重点突出；
2.关于技术问题：（见参考题）
3.关于软性问题：候选人负责的工作及体验、对部门对公司贡献的价值、最有成就感的事、对于自己未来的规划，对太平洋健康怎么看的，表现出高意愿度这个是后续流程推进的一个重要考虑因素，技术栈或者行业知识不会的也不要慌，尽可能回答并标示出主动学习尽快融入的想法。谈吐落落大方即可，前两轮主要是业务和项目技术方向的，其他的都不是重点，薪资方面的可适当弱化，后续我也是会争取的，切勿表现出钱是唯一的考虑点，北京这边的面试官偏严肃风格，朴实型所以面试时风格建议务实一些。
软性问题
1.怎么应对工作的难点、挑战
2.技能优化
3.之前工作的团队氛围怎么样
4.你觉得你的性格是怎样的
 
技术题：
1.      redis加锁解锁过程？
2.      怎么保证解锁过程可以正确解锁 value设置唯一id，解锁的时候判断value是否相等？
3.      redis缓存怎么构建？
4.      怎么保证数据一致性？
5.      强一致性就是先删除缓存+写db+写缓存？
6.      kafka消费逻辑怎么保证？
7.      幂等+手动提交offset；
8.      mysql索引创建 组合索引、最左匹配在大数据量的情况下有什么差别？
9.      rpc框架的服务注册与发现怎么实现？
10.  怎么保证寻址的时候provider是可用的？
11.  心跳检测，es索引的数据结构，本地线程里的变量怎么传递给其他线程？
12.  redis场景问题，限流、熔断、热点key；
13.  Apollo实现动态配置更新的原理，以及架构怎么设计实现；
14.  springboot如何实现一个线程池，并提供调用；
15.  怎么定义一个aop，AOP用到哪些注解；
16.  Threadlocal如何实现，有什么问题，如何在线程之间进行值传递；
17.  redis集群实现；
18.  springboot自动装配原理；
19.  长连接如何实现？
20.  nginx有用过吗 平时都会用到哪些参数
21.  nginx的安全配置了解不？
22.  介绍下你负责的系统，系统介绍过程中不断地问技术细节
23.  tcp优化
24.  mysql事务是怎么回滚的
25.  mysql覆盖索引说一说
26.  mysql用的存储引擎介绍下
27.  sql优化工作中有没有用到
28.  k8s有用过吗
29.  docker是怎么做到宿主机隔离的
30.  redis你在项目里都用了哪些场景
31.  redis底层数据结构有没有了解过
32.  谈一谈redis的string底层实现
33.  redis string类型的字符串长度计算时间复杂度是多少
34.  给了三个mysql的where条件字段 a=性别,b=时间,c=姓名  怎么建立索引使其最优查询（索引区分度）
35.  kafka发消息怎么保证不丢失，异步发送具体怎么用的
36.  kafka broker端怎么处理消息
37.  mysql分库分表在项目里怎么做的
 
1.项目介绍
2.项目运行的流程？
3.责任链模式和策略模式的区别？
4.如何处理并发问题？加锁(synchronized、lock)、部分场景可以使用threadLocal
5.介绍了自己平时在项目中发现的问题，比如如何优化一个线程池？核心线程、最大线程数、队的长度如何考虑？
6.threadLocal原理以及源码介绍(因为之前做过技术分享)
7.如何跨线程访问同一个变量？父子变量可以用inheritableThreadLocal
8.线程池里用ThreadLocal的注意点
9.Http状态码，100、400...都代表什么？
10.设计一个查询接口会怎么考虑？访问量、qps、降级、限流
11.如何设计一个Mq集群，一个集群都有哪些东西？producer、consumer...
12.如何优化一段慢SQL？避免嵌套查询、不使用模糊的表别名、让字段尽可能命中索引...
13.索引的最左匹配原则？
 
1 kafka的并发量是如何做到那么大的？
2 kafka rebalance 时候发生了什么？
3 如何设计一个微博/抖音的评论系统
4 reentrant lock公平锁底层实现原理
5 如何在代码中避免死锁
