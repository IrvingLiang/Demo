
负载因子为什么是0.75
HashMap 的默认负载因子（Load Factor）设置为 0.75 是一个经过深入研究和实践验证的空间与时间效率的平衡点。这个值的选择主要基于以下几个关键原因：

冲突概率与空间利用率的平衡：

负载因子 = 元素数量 / 哈希表容量。它表示哈希表的空间被“填满”的程度。
负载因子过低（如0.5）： 空间利用率低，意味着哈希表有大量的空桶，浪费内存。虽然冲突概率很低（查找速度快），但需要更频繁地扩容（当元素数量达到 容量*0.5 时就扩容），扩容操作（rehash）成本高昂。
负载因子过高（如0.9）： 空间利用率很高，节省内存。但哈希表接近满载，发生哈希冲突的概率急剧增加。冲突增多会导致：
链表变长（在Java 8之前的HashMap中，或当桶中元素<=8时）：查找时间从接近O(1)退化到O(n)。
链表转红黑树（Java 8及以后，当桶中元素>=8时）：虽然红黑树查找效率是O(log n)，但仍然比直接命中单个节点（O(1)）慢，且转换操作本身也有开销。
0.75： 被认为是一个“甜蜜点”。在这个值下：
冲突的概率被控制在了一个相对较低且可接受的水平，保证了平均查找时间复杂度接近O(1)。
空间利用率也达到了一个比较合理的水平（75%），避免了内存的过度浪费。
不需要过于频繁地进行扩容。
统计学基础（泊松分布）：

Java HashMap 的实现（特别是Java 8的优化）参考了泊松分布来分析哈希冲突的概率。
当负载因子为0.75时，根据泊松分布的公式计算，一个哈希桶（链表）中出现：
0个元素的概率 ≈ 0.49（接近一半的桶是空的）
1个元素的概率 ≈ 0.16
2个元素的概率 ≈ 0.08
3个元素的概率 ≈ 0.03
8个元素（Java 8中链表转红黑树的阈值）的概率 ≈ 0.00000006 (1e-7)，极其罕见。
这意味着在负载因子0.75下，绝大多数桶只有0、1或2个元素，链表长度超过8的概率微乎其微，平均查找性能非常优秀。
避免频繁扩容：

扩容（resize()）是一个代价高昂的操作：需要分配一个更大的新数组，然后遍历旧数组的所有元素，重新计算它们的哈希值在新数组中的位置（rehash），并将元素复制到新数组。
负载因子0.75意味着在哈希表填满75%时就会触发扩容，为后续元素的插入预留了25%的空间。这有效地推迟了下一次扩容的到来，减少了扩容操作的频率。
经验值与实践验证：

0.75这个值并非凭空而来，而是计算机科学家长期研究哈希表性能、结合数学理论和大量实践经验得出的一个被广泛接受的经验值。
在Java HashMap的长期应用中，0.75被证明在绝大多数常见场景下都能提供最佳的综合性能（查询速度、插入速度、内存消耗）。
总结：

HashMap选择0.75作为默认负载因子，是空间效率（内存占用）和时间效率（查找/插入速度）之间经过严格权衡的结果：

它最大程度地减少了哈希冲突（保证了平均O(1)的查找性能）。
同时提供了合理的空间利用率（75%），避免了内存的过度浪费。
有效地降低了扩容操作的频率。
这个值有统计学基础（泊松分布），确保了极端冲突（长链表或频繁树化）的概率极低。
它是长期实践验证的经验最优值。

HashMap的思考
  hashMap的构造方法中的初始化大小指的是数组的大小，而不是元素的个数,但是扩容的时候比较的是元素个数是否达到了阈值，因此这里其实是考虑没有hash冲突的时候数组大小和元素个数是一样的
  内部的数组会在第一次put的时候进行创建，如果初始化设置里的大小（不传默认是16），会创建大小为2的幂的数组，这个大小刚好会大于指定的大小（比如设置13，最终是16，设置17最终是32）

HashMap，hashTable，concurrentHashMap
 
   

垃圾回收器的介绍
https://juejin.cn/post/7216967809158299703
